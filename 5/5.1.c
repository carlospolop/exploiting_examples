#include <stdio.h>
#include <string.h>

int func(char *arg){
	char buf[40];
	strncpy(buf, arg, 64);
	return 0;
}
int main(int argc, char *argv[]){
	if(strchr(argv[1], 0xbf)){
		printf("intento de hacking");
		exit(1);	
	}
	func(argv[1]);
	return 0;
}

/*
La shellcode podría haber sido:
shellcode+"A"*(52-len(shellcode))+&ret

De esta forma sobreescribimos el EIP con un ret que tomará la dirección del parametro pasado (es decir, pondrá en EIP la dirección donde se guardó la shellcode pues esta dirección es lo que se pasa como parámetro a la función func).
 Sin embargo, al llamar a func se mete en la pila la direción del parámatro (shellcode), pero, tras llamar a strncpy, esta dirección guardada se pone a 0. Así que cuando se va a ejecutar el ret sobreescrito no hay nada a continuación.

